 От студента:

Автор: Федоров Руслан
Ник: aspcartman
Группа: 111
email: aspcartman@gmail.com
IDE: Intellij IDEA
OS: MacOSX 10.9 Developer Preview 6
JavaVersion: 1.6.0_51-b11-457-11M4509

Коментарии:
Выполнил 3 задания (PortScanner, Archiver и ArchiveComparator) и начал делать JCL и решил приложить наработки.

Вижу Java в первый раз и по этому решил делать задание вширь и в случае PortScanner'a больше, чем просили в задании, пусть и не получу за это баллов. Так же я практически не использовал сторонние библиотеки по этой же причине.

Пытался имплементировать знакомые паттерны. Коментариев в коде практически нет тк упор делал на self-describing code: после некоторого опыта работы и прочтения Clean Code(Robert C. Martin, http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) считаю, что коментарии вредны по ряду причин (где основная причина для меня то, что при изменениях в коде комментарии исправлять забывают) и код должен быть понятен без них, иначе требуется рефакторинг. Я осознаю, что это спорный момент, но тем не мение. Следовательно имена некоторых переменных и методов могут показаться слишком длинными и количество служебных методов у простого класса слишком большим. Код по большей части расположен в удобном для чтения виде - методы идут в порядке вызовов за исключением тех мест, где Intellij IDEA по не известным пока причинам сбивала этот порядок. Желательно читать код используя средства IDE.

Из работы убраны JUnit4 тесты по причине того, что большая часть тестируемых методов - приватны, а использование Reflection для решение этой проблемы достаточно не удобно. Сильно скучая по селекторам из Obj-C (и просто указателям на функции) имплементировал метод из Obj-C NextStep фреймворка [NSObject performSelectorInBackground:sel], исполняющий передаваемый аргументом метод в отдельном треде (помня про анонимные классы и Runnable) и используя эту наработку можно было бы решить данную проблему. Но в Java для получения метода нужно указать не только его имя строкой (уже потеря статического анализа), но и классы его аргументов, что влечет за собой очевидные минусы поддержки и читабельности. Наработка так же исключена из задания.

Использовал в некоторых местах Checked Exceptions, но по большей части на данном этапе изучения языка механизм исключений привносит больше неудобств, чем пользы.

В требованиях не было четко указанно придерживаться конкретного CodeStyle, пусть и была дана ссылка на онный. Я придерживался своего. Названия методов с заглавной и фигурные на отдельных строках. Геттеры без слова get. Скорее всего в дальнейшем CodeStyle будет у меня подкоректирован под реалии Java :)

PortScanner:
Сканирует переданные в аргументах командной строки порты. Помимо адреса и портов (можно просканировать просто один порт) опционально можно указать, печатать ли закрытые порты (при большом сканировании строки о закрытости порта попросту захламляют output) и таймаут сокета. Так же в этой задаче имплементировал паттерн делегирования. Как приятное дополнение - сделал строку прогресса, отображающую текущий порт во время сканирования.

Comparator:
"Самое сложное в программировании - придумывать названия переменным"
ArchiveCREntry и ArchiveEntryCR (CR - ComparisonResult). Схожесть сбивает с толку. Как назвать иначе не придумал.
Библиотека Swing, предоставляющая JFileChooser, на моей ОС и версии Java сыплет исключениями в поток ошибок, однако не рушится.
Имплементировал случай переменовки. Печатает результат как в файл, так и в stdout.

Archiver:
Задачи про архивы преднамеренно не используют наработок друг друга.
Обернул HashMap<String, File> в FileList исключительно из итоговой читабельности, но для полноты картины нужно в этом враппере имплементировать оболочку для итерации.
Архиватор не пытается рекурсивно заархивировать архив, в который пишет. Точно.

JCL:
Многопоточность и IO.
Столкнулся с проблемой при решении задачи. При запуске процессов и подсоединении их к стандартным потокам IO, поток перенаправления блокировался на read() к stdin и, на сколько мне известно, единственный способ его от stdin оторвать - закрыть stdin. Можно было бы использовать неблокирующий режим и busy-wait, но с моей точки зрения в данной ситуации busy-wait не приемлем. В итоге я имплементировал класс ShieldedStdInputStream, который пропускал данные из stdin через PipedStream. Соответственно при перенаправлении код уже блокировался на read() не к stdin, а к этому пайпу, закрыть который (и тут же открыть) труда не составляет. Открытие забито сразу в close(). Плюс для stdout использовал обычный ShieldedStream из Apache.Commons, который просто занулял имплементацию метода close().
Плюс использовал в имплементации Command synchronized блоки с Object.notify и volatile переменные.

Задания реализуются очень быстро и приятно, но это если их решать по быстрому на результат. Если пытаться оформлять код и делать красиво, то уходит на удивления много времени. TDD скорости не способствует.
